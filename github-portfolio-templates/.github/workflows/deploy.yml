name: Deploy to Production

on:
  push:
    branches: [ main ]
    tags: [ 'v*' ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Build and push Docker image
  build:
    name: Build & Push Image
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    
    outputs:
      image: ${{ steps.image.outputs.image }}
      digest: ${{ steps.build.outputs.digest }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}
          type=sha,prefix=sha-

    - name: Build and push Docker image
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        platforms: linux/amd64,linux/arm64
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Output image
      id: image
      run: |
        echo "image=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ steps.build.outputs.digest }}" >> $GITHUB_OUTPUT

  # Deploy to staging
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: build
    environment: 
      name: staging
      url: https://staging.yourplatform.com
    if: github.ref == 'refs/heads/main' || github.event.inputs.environment == 'staging'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: us-east-1

    - name: Deploy to ECS
      run: |
        # Update ECS service with new image
        aws ecs update-service \
          --cluster staging-cluster \
          --service trading-platform-staging \
          --force-new-deployment
        
        # Wait for deployment to complete
        aws ecs wait services-stable \
          --cluster staging-cluster \
          --services trading-platform-staging

    - name: Run database migrations
      run: |
        aws ecs run-task \
          --cluster staging-cluster \
          --task-definition trading-platform-migrate \
          --launch-type FARGATE \
          --network-configuration "awsvpcConfiguration={subnets=[subnet-12345],securityGroups=[sg-12345],assignPublicIp=ENABLED}"

    - name: Health check
      run: |
        for i in {1..30}; do
          if curl -f https://staging.yourplatform.com/health; then
            echo "Health check passed"
            exit 0
          fi
          sleep 10
        done
        echo "Health check failed"
        exit 1

    - name: Run smoke tests
      run: |
        npm ci
        npm run test:smoke -- --env=staging

  # Deploy to production
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [build, deploy-staging]
    environment: 
      name: production
      url: https://yourplatform.com
    if: startsWith(github.ref, 'refs/tags/') || github.event.inputs.environment == 'production'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: us-east-1

    - name: Create deployment
      id: deployment
      uses: actions/github-script@v7
      with:
        script: |
          const deployment = await github.rest.repos.createDeployment({
            owner: context.repo.owner,
            repo: context.repo.repo,
            ref: context.sha,
            environment: 'production',
            description: 'Deploying to production',
            auto_merge: false
          });
          return deployment.data.id;

    - name: Update deployment status to in_progress
      uses: actions/github-script@v7
      with:
        script: |
          await github.rest.repos.createDeploymentStatus({
            owner: context.repo.owner,
            repo: context.repo.repo,
            deployment_id: ${{ steps.deployment.outputs.result }},
            state: 'in_progress',
            description: 'Deployment in progress'
          });

    - name: Deploy to ECS (Blue/Green)
      run: |
        # Create new task definition
        NEW_TASK_DEF=$(aws ecs describe-task-definition \
          --task-definition trading-platform-prod \
          --query 'taskDefinition' \
          | jq --arg IMAGE "${{ needs.build.outputs.image }}" \
            '.containerDefinitions[0].image = $IMAGE | del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .placementConstraints, .compatibilities, .registeredAt, .registeredBy)')
        
        # Register new task definition
        NEW_TASK_DEF_ARN=$(echo $NEW_TASK_DEF | aws ecs register-task-definition \
          --cli-input-json file:///dev/stdin \
          --query 'taskDefinition.taskDefinitionArn' \
          --output text)
        
        # Update service with new task definition
        aws ecs update-service \
          --cluster production-cluster \
          --service trading-platform-prod \
          --task-definition $NEW_TASK_DEF_ARN
        
        # Wait for deployment to complete
        aws ecs wait services-stable \
          --cluster production-cluster \
          --services trading-platform-prod

    - name: Run database migrations
      run: |
        aws ecs run-task \
          --cluster production-cluster \
          --task-definition trading-platform-migrate-prod \
          --launch-type FARGATE \
          --network-configuration "awsvpcConfiguration={subnets=[subnet-prod-1,subnet-prod-2],securityGroups=[sg-prod],assignPublicIp=ENABLED}"

    - name: Health check
      run: |
        for i in {1..60}; do
          if curl -f https://yourplatform.com/health; then
            echo "Production health check passed"
            exit 0
          fi
          sleep 10
        done
        echo "Production health check failed"
        exit 1

    - name: Run production smoke tests
      run: |
        npm ci
        npm run test:smoke -- --env=production

    - name: Update deployment status to success
      if: success()
      uses: actions/github-script@v7
      with:
        script: |
          await github.rest.repos.createDeploymentStatus({
            owner: context.repo.owner,
            repo: context.repo.repo,
            deployment_id: ${{ steps.deployment.outputs.result }},
            state: 'success',
            description: 'Deployment successful',
            environment_url: 'https://yourplatform.com'
          });

    - name: Update deployment status to failure
      if: failure()
      uses: actions/github-script@v7
      with:
        script: |
          await github.rest.repos.createDeploymentStatus({
            owner: context.repo.owner,
            repo: context.repo.repo,
            deployment_id: ${{ steps.deployment.outputs.result }},
            state: 'failure',
            description: 'Deployment failed'
          });

  # Rollback on failure
  rollback:
    name: Rollback on Failure
    runs-on: ubuntu-latest
    needs: [deploy-production]
    if: failure()
    environment: production
    
    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: us-east-1

    - name: Rollback to previous version
      run: |
        # Get previous stable task definition
        PREVIOUS_TASK_DEF=$(aws ecs list-task-definitions \
          --family-prefix trading-platform-prod \
          --status ACTIVE \
          --sort DESC \
          --query 'taskDefinitionArns[1]' \
          --output text)
        
        # Update service to previous version
        aws ecs update-service \
          --cluster production-cluster \
          --service trading-platform-prod \
          --task-definition $PREVIOUS_TASK_DEF
        
        # Wait for rollback to complete
        aws ecs wait services-stable \
          --cluster production-cluster \
          --services trading-platform-prod

    - name: Notify team of rollback
      uses: 8398a7/action-slack@v3
      with:
        status: custom
        custom_payload: |
          {
            text: "ðŸš¨ Production deployment failed and was rolled back",
            attachments: [{
              color: "danger",
              fields: [{
                title: "Repository",
                value: "${{ github.repository }}",
                short: true
              }, {
                title: "Commit",
                value: "${{ github.sha }}",
                short: true
              }]
            }]
          }
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}